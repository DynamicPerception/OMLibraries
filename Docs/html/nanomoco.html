<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OpenMoCo AVR Libraries: Controlling nanoMoCo Devices with OMAxis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenMoCo AVR Libraries
   </div>
   <div id="projectbrief">Motion Control and MoCoBus Libraries for the AVR Platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('nanomoco.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Controlling nanoMoCo Devices with <a class="el" href="class_o_m_axis.html">OMAxis</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>You can control up to 32 nanoMoCo devices at once per MoCoBus. The <a class="el" href="class_o_m_axis.html">OMAxis</a> class creates a high-level interface to all commands the nanoMoCo can accept, including all status commands.</p>
<p>The <a class="el" href="class_o_m_axis.html">OMAxis</a> class is an OMMoCoMaster-derived class, so you can perform lower-level activities if you prefer, however this should not be necessary.</p>
<h1><a class="anchor" id="nmdevaddr"></a>
Device Addressing</h1>
<p>To reduce overall memory footprint, one <a class="el" href="class_o_m_axis.html">OMAxis</a> instance can be used for up to 32 distinct nanoMoCo devices. This is achieved by passing an address to the target() method, which sets the address for subsequent commands.</p>
<p>For example, we can send the same commands to multiple nodes in a loop:</p>
<div class="fragment"><div class="line">    <span class="comment">// note: include all headers due to issues with Arduino build process</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"> #include &quot;OMMoCoBus.h&quot;</span></div>
<div class="line"><span class="preprocessor"> #include &quot;OMMoCoMaster.h&quot;</span></div>
<div class="line"><span class="preprocessor"> #include &quot;<a class="code" href="_o_m_axis_8h.html">OMAxis.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"> byte addresses[3] = { 4, 5, 6 };</div>
<div class="line"> </div>
<div class="line"> <a class="code" href="class_o_m_axis.html">OMAxis</a> Axis = <a class="code" href="class_o_m_axis.html">OMAxis</a>(Serial);</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> setup() {</div>
<div class="line">    Serial.begin(OM_SER_BPS);</div>
<div class="line"> </div>
<div class="line">    sendCommands();</div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> loop() {</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> }</div>
<div class="line"> </div>
<div class="line"> <span class="keywordtype">void</span> sendCommands() {</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>( byte i = 0; i &lt; <span class="keyword">sizeof</span>(addresses) * <span class="keyword">sizeof</span>(byte); i++ ) {</div>
<div class="line"> </div>
<div class="line">        Axis.<a class="code" href="class_o_m_axis.html#ad764aa98f9c56aaff32cbd62246c1bdd">target</a>( addresses[i] );</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span>( Axis.<a class="code" href="class_o_m_axis.html#a59fc494d53391b27e2fd75cb750690d9">connected</a>() ) {</div>
<div class="line">            Axis.<a class="code" href="class_o_m_axis.html#ad8d61baeb1d4c8927c66e8b486282382">enableCamera</a>(<span class="keyword">false</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> }</div>
</div><!-- fragment --><p>NB: You'll see connected() used a lot in the examples. Its use should be abundant when sending commands to nodes, it tells you whether or not the node is connected and responding to commands at that address.</p>
<p>If you wish to set device addresses via your Arduino sketch, look at the changeAddress() method, otherwise you can use any other facility for setting device addresses, like Graffik.</p>
<p>Each nanoMoCo device <b>must</b> have a unique address, otherwise communication will be impaired on the bus - as two devices will attempt to respond at once.</p>
<h1><a class="anchor" id="nmenable"></a>
Enabling Functions on the nanoMoCo</h1>
<p>Most functions of the nanoMoCo can be enabled/disabled. You should always ensure, before starting a series of commands, or after having completed a programmed activity, that the functions you need enabled/disabled are so. Do not rely any expected defaults.</p>
<p>Some high-level functions, such as motor driving and camera control, are enabled using specific boolean parameters to enable or disable all related functions, these include enableCamera() and enableMotor().</p>
<p>Other functions, such as controlling the focus line, delaying after a shot, or exposing the camera are enabled or disabled by specifying how long the activity should occur for. For example, to disable focus line control, we simply set focus time to 0ms with focus(). By specifying 0 time to execute any given activity, we disable that activity.</p>
<h1><a class="anchor" id="nminteractivesms"></a>
Interactive Control with Discrete Movements</h1>
<p>The most simple form of motion control to understand is that of interactive control. In interactive control, you tell each nanoMoCo device exactly what to do, and when to do it. By 'discrete movements' we mean that we're going to issue commands for very specific moves to points. For example, if we wanted to perform a shoot-move-shoot move for five shots with one nanoMoCo, we can use the expose() and simple move() methods:</p>
<div class="fragment"><div class="line"> <span class="keywordflow">for</span>( byte i = 0; i &lt; 5; i++) {</div>
<div class="line"> </div>
<div class="line">    Axis.<a class="code" href="class_o_m_axis.html#ab4b56340ca1db562e1fc3138c517e534">expose</a>(500);</div>
<div class="line">    delay(500);</div>
<div class="line"> </div>
<div class="line">    Axis.<a class="code" href="class_o_m_axis.html#aed8b4d5396b77e310d58da8c3d8a8e82">move</a>(<span class="keyword">true</span>, 100);</div>
<div class="line">    delay(500);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>When using the simple move() method to create discrete movements, the motor will accelerate quickly and move at a speed up to the maximum speed you've set via maxSpeed().</p>
<p>All moves, camera controls, etc. are non-blocking. This means you may continue to send commands, and even perform other actions while these commands are being executed.</p>
<h1><a class="anchor" id="nminteractivec"></a>
Interactive Control with Continuous Movement</h1>
<p>Like moving with discrete movements (e.g. SMS), we can also do direct, interactive control with continuous movement. In this case, instead of telling the nanoMoCo how many steps to take, we tell it what speed we want it to move at.</p>
<p>To execute a standard continuous move, we have to do a few things:</p>
<ul>
<li>
Tell the nanoMoCo that movement will be continuous </li>
<li>
Tell it what speed to move at </li>
<li>
Tell it to start moving </li>
</ul>
<p>The following code shows us how to do this:</p>
<div class="fragment"><div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a6f3d04cd3cb73b6ef3b7c3ce7b4f22c5">continuous</a>(<span class="keyword">true</span>); <span class="comment">// enable continuous motion</span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#affb7efc66b76684f74d074e682b8da36">continuousSpeed</a>(1.5); <span class="comment">// steps per second</span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#aed8b4d5396b77e310d58da8c3d8a8e82">move</a>(<span class="keyword">true</span>, 0); <span class="comment">// start moving</span></div>
</div><!-- fragment --><p>The continuous speed is expressed in steps per second, and is a floating-point value. You may, and should, change the speed during the move. Note that no acceleration or deceleration is done for you, you must accelerate and decelerate by modulating the speed.</p>
<p>Our call to move() here is special: note that we told it to go 0 steps. When moving continuously, we control the speed and not the total steps via the move command.</p>
<p>The motor will continue running at the last set speed until one of the following occurs:</p>
<ul>
<li>
stop() is called </li>
<li>
stopMotor() is called </li>
<li>
maxSteps() is reached </li>
</ul>
<p>NB: You may reset a maxSteps() counter at any time by sending a stop() command, which resets all counters.</p>
<p>Of course, this kind of continuous motion control is both boring and a lot of work to implement. Let's look at something more interesting...</p>
<h1><a class="anchor" id="nminteractivecm"></a>
Interactive Control with Complex Movement</h1>
<p>We can perform a complex continuous move with a specified distance to travel, time to travel, acceleration period, and deceleration period by using the complex move() method. This method takes more arguments than the simple move() method, and allows us to create far more expressive moves with a single line of code.</p>
<p>For more information on how the complex moves, and what the result looks like, see <a class="el" href="ommotion.html">Motion Capabilities</a>.</p>
<p>For example, the following command causes a move to be executed:</p>
<div class="fragment"><div class="line"> Axis.<a class="code" href="class_o_m_axis.html#aed8b4d5396b77e310d58da8c3d8a8e82">move</a>(<span class="keyword">true</span>, 5000, 60000, 3000, 2000);</div>
</div><!-- fragment --><p>This would be a lot more work to do interactively just using a basic continuous move, plus we don't have to worry about calling continuous() or setting a continuousSpeed(). The nanoMoCo simply calculates for us what speed to be going, and how far it has gone, every tiny fraction of a second.</p>
<p>NB: If you specify a move that cannot be made within current parameters (too far too quickly), you will not get an error or warning, but your motor will mvoe erratically, and may attempt to make a very long move at the end of the movement to catch up to the desired position.</p>
<h1><a class="anchor" id="nmprogram"></a>
Basic Programmed Activities</h1>
<p>The real power of the nanoMoCo shines when we get to programmed activities. Unlike interactive control, we don't have to keep timing and issue each command ourselves. Instead, we tell the nanoMoCo what we want it to do, and it manages what it takes to do that for us.</p>
<p>The most basic form of this is a shoot-move-shoot move with no "output" acceleration. By this, we mean that the distance moved between each exposure doesn't change. Each discrete movement has a brief acceleration and deceleration period.</p>
<p>To achieve this, we will tell the nanoMoCo what its operating parameters are, and then to start executing them:</p>
<div class="fragment"><div class="line"> Axis.<a class="code" href="class_o_m_axis.html#ae55e5f9def51e74661fb5d1014364e52">enableMotor</a>(<span class="keyword">true</span>); <span class="comment">// motor will be enabled</span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#ad8d61baeb1d4c8927c66e8b486282382">enableCamera</a>(<span class="keyword">true</span>); <span class="comment">// camera will be enabled</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#ab2416ad8c5e2c604ebcf611ccba2bdf6">interval</a>(1000); <span class="comment">// 1-second exposure interval</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a7f073fa93ecd96f483633974b6aafb8a">steps</a>(50); <span class="comment">// move 50 steps between each exposure</span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a8ab789fefaf519d329288f358bff3a7e">dir</a>(<span class="keyword">true</span>); <span class="comment">// move in the &#39;true&#39; direction</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a0389076fe82318cafb30bff44c6f6077">exposure</a>(250); <span class="comment">// trigger exposure for 250mS</span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a93bfbce6181b44c0ac92f5d8a9c9f3bc">exposureDelay</a>(300); <span class="comment">// delay for 300mS after exposure before moving</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#aaaa502fc6b8c78de747c614f652baf8d">maxShots</a>(100); <span class="comment">// take a maximum of 100 exposures</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#aad5997aaaa2d622f0ca57f8b24a51a7b">start</a>(); <span class="comment">// begin executing the program</span></div>
</div><!-- fragment --><p>In the above example, the axis will move 50 steps in the 'true' direction between each exposure, and there will be at least 1 second between each exposure.</p>
<p>You may pause execution of a SMS motion program at any time by using pause(), and resume it again using start(). You may stop the program execution entirely by using the stop() command. The program will automatically stop when one of the following occurs:</p>
<ul>
<li>
maxShots() is reached </li>
<li>
maxRunTime() is reached </li>
</ul>
<p>If maxSteps() is reached, the motor will stop moving, but the program will otherwise continue operating.</p>
<h1><a class="anchor" id="nmprogramadv"></a>
Expressive Programmed Moves</h1>
<p>We can achieve much more expressive programmed moves using the plan() method. The plan() control tells the motor to make a complex move once the program is started using start(). While basic programmed moves only let us do SMS-style movements, planned movements can be either continuous or interleaved between exposures.</p>
<p>The plan() adds one additional argument that the complex move() method does not - and that is whether the move is continuous, or SMS-style. We still have to setup the camera like we would normally.</p>
<div class="fragment"><div class="line"> Axis.motorEnable(<span class="keyword">true</span>); <span class="comment">// motor will be enabled</span></div>
<div class="line"> Axis.cameraEnable(<span class="keyword">true</span>); <span class="comment">// camera will be enabled</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#ab2416ad8c5e2c604ebcf611ccba2bdf6">interval</a>(1000); <span class="comment">// 1-second exposure interval</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a0389076fe82318cafb30bff44c6f6077">exposure</a>(250); <span class="comment">// trigger exposure for 250mS</span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a93bfbce6181b44c0ac92f5d8a9c9f3bc">exposureDelay</a>(300); <span class="comment">// delay for 300mS after exposure before moving</span></div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a8d732f1a3f430537aa9e35992398f6fb">plan</a>(<a class="code" href="_o_m_axis_8h.html#a5fe0b13b17894dcee86f77e74e467f52ac9f13d1782b3e4422a06cedef03aaf37">PLAN_CONTINUOUS</a>, <span class="keyword">true</span>, 5000, 60000, 3000, 2000); <span class="comment">// plan a complex move </span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#aad5997aaaa2d622f0ca57f8b24a51a7b">start</a>(); <span class="comment">// begin executing the program</span></div>
</div><!-- fragment --><p>Now, unlike our previous programmed activity, we have expressed not only some movement, but the final target position, the time to arrive there, how long to accelerate, and how long to decelerate.</p>
<p>For continuous moves, the times used in a plan (arrival time, acceleration time, and deceleration time) are all expressed in milliseconds. For interleaved (SMS) moves, the times expressed are intervals.</p>
<p>We can also express a delay before the movement is to start, we do this using the delayMoveStart() command. Like with plan, delayMoveStart() values are milliseconds for continuous moves, or intervals for interleaved motion.</p>
<p>Planned move programs follow the same stop profile as a basic programmed move.</p>
<p>An interleaved planned move may be paused and re-started without issue, however, it is not possible to pause a continuous planned move as stepper motors are not capable of starting movement at high speeds, and must accelerate into such speeds.</p>
<h1><a class="anchor" id="nmeasing"></a>
Setting Easing Mode for Expressive Programmed Moves</h1>
<p>We all know that being limited to, say, linear acceleration, can be really boring in the final output video. With the nanoMoCo, it is possible to choose from Linear, Quadratic, or Inverse Quadratic easing profiles to get that extra punch in moves. The selected easing profile is used for any complex move() or plan(), whether it is continuous or interleaved. Simply call easing() before sending the move command or starting the program.</p>
<p>You should not change easing profiles while a move is being executed, or a program is running. Doing so will result in undefined behavior.</p>
<h1><a class="anchor" id="nmsynchro"></a>
Synchronizing Multiple Nodes</h1>
<p>When operating with multiple nodes, it is important that some synchronization is performed between them. In the case of SMS movement, this is essential to prevent the nodes that are not controlling the camera to know when it is safe to move. This is achieved using the master() method. Only one node should ever be set to master.</p>
<p>The master will send a clear to move signal to the slaves using COM3 when the exposure is complete, and the exposure delay has expired.</p>
<div class="fragment"><div class="line">    <span class="comment">// set address 4 as master, all else as slaves</span></div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#ad764aa98f9c56aaff32cbd62246c1bdd">target</a>(4);</div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a229e6bb223d55b0185b7e93dc01f80d9">master</a>(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#ad764aa98f9c56aaff32cbd62246c1bdd">target</a>(5);</div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a229e6bb223d55b0185b7e93dc01f80d9">master</a>(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#ad764aa98f9c56aaff32cbd62246c1bdd">target</a>(6);</div>
<div class="line"> Axis.<a class="code" href="class_o_m_axis.html#a229e6bb223d55b0185b7e93dc01f80d9">master</a>(<span class="keyword">false</span>);</div>
</div><!-- fragment --><p>The node controlling the camera must always be set as the master. Controlling multiple cameras from slaves is possible, but the master or other nodes may move while they are exposing.</p>
<p>For slave nodes, the interval value is ignored. This means that for interleaved motion, the slave nodes will only move after the master has sent the slave clear signal. For continuous motion, master is less important, obviously, as motors will move at their needed speeds at the right times.</p>
<p>To start, stop, or pause multiple nodes at the same time, use the broadcast forms of the commands.</p>
<h1><a class="anchor" id="nmstatus"></a>
Requesting Operational Status</h1>
<p>You can request operational status from any nanoMoCo node by using the methods whose names start with 'get', e.g. getRunning().</p>
<p>You should always check to see if the node is connected and responding, otherwise the results returned by these methods are not reliable.</p>
<div class="fragment"><div class="line"> <span class="keywordflow">if</span>( Axis.<a class="code" href="class_o_m_axis.html#a59fc494d53391b27e2fd75cb750690d9">connected</a>() ) {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> runTime - Axis.<a class="code" href="class_o_m_axis.html#a9bcb4f1baaaf870ceb86c96918ca3586">getRunTime</a>();</div>
<div class="line"> }</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Aug 12 2013 17:24:00 for OpenMoCo AVR Libraries by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>
